import pygame
import random
pygame.init()

clock = pygame.time.Clock()
FPS = 30

#create game window
SCREEN_WIDTH = 1280
SCREEN_LENGTH = 793

screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_LENGTH))
pygame.display.set_caption("Worldly Mage")

#define colors

red = (255, 0, 0)
green = (0, 255, 0)
#background music and start image
bg_music = pygame.mixer.Sound('Audio/bk_music.mp3')
bg_music.play(loops = -1)
bg_music.set_volume(0.45)

start_img = pygame.image.load('Game_start.png').convert()
#background images loading in the parallax
bg_images = []
for i in range(1, 13):
    sheet = pygame.image.load(f"Background/Layer_{i:04}.png").convert_alpha()
    bg_images.append(sheet)
bg_width = bg_images[0].get_width()
WORLD_WIDTH = bg_width * 6

#text for health

def draw_text(text, font, text_col, x, y):
    img = font.render(text, True , text_col)
    screen.blit(img, x, y)

def draw_bg(camera_offset_x):#create the speed for the scroll
    screen.fill((0, 0, 0))
    camera_offset_x = int(camera_offset_x)
    speed = 0.2

    for sheet in reversed(bg_images[1:]):
        rel_x = -camera_offset_x * speed 
        x_pos = rel_x % bg_width - bg_width
        while x_pos < SCREEN_WIDTH:
            screen.blit(sheet, (x_pos, 0))
            x_pos +=bg_width
        speed += 0.2
        ground_layer = bg_images[0]
        ground_y = SCREEN_LENGTH - ground_layer.get_height()

    #Draw the ground layer at the bottom
    start_x = -(camera_offset_x % bg_width)
    tiles_needed = (SCREEN_WIDTH // bg_width) + 2
    for i in range(tiles_needed):
            screen.blit(ground_layer, (start_x + i * bg_width, ground_y))
restart_img = pygame.image.load('Restart_btn.png').convert_alpha()

class Button():
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.clicked = False

    def draw(self):
        action = False
        #get mouse position
        pos = pygame.mouse.get_pos()
        #check mouse movesand clicked conditions
        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False:
                action = True
                self.clicked = True
        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False
        #draw button
        screen.blit(self.image, self.rect)
        return action

class Character():
    def __init__(self, pos_x, pos_y, name, max_hp, animation_steps = 4, scale = 3):
        self.reset(pos_x, pos_y, name, max_hp, animation_steps, scale)

    def update(self):
        #dead state for character
        if not self.alive:
            self.action = 4  # death
            animation_cooldown = 120

            bottom = self.rect.bottom
            centerx = self.rect.centerx
            self.image = self.animation_list[self.action][self.frame_index]
            self.rect = self.image.get_rect()
            self.rect.bottom = bottom
            self.rect.centerx = centerx

            if pygame.time.get_ticks() - self.last_update > animation_cooldown:
                self.last_update = pygame.time.get_ticks()
                self.frame_index += 1
                if self.frame_index >= len(self.animation_list[self.action]):
                    self.frame_index = len(self.animation_list[self.action]) - 1  # hold last frame
            return  #stops the input


        #alive idle state
        dx = 0
        dy = 0
        key = pygame.key.get_pressed()

        # MOVEMENT INPUT
        if key[pygame.K_LEFT]:
            dx -= 10
            self.flip = True
        if key[pygame.K_RIGHT]:
            dx += 10
            self.flip = False

        # JUMP INPUT 
        if (key[pygame.K_SPACE] or key[pygame.K_UP]) and not self.jumped:
            self.vel_y = -15
            self.jumped = True
            self.action = 2  # jump
            self.jump_sound.play()

        # ATTACK INPUT
        if key[pygame.K_q] and not self.attacking:
            self.attacking = True
            self.action = 3
            self.frame_index = 0
            self.last_update = pygame.time.get_ticks()
            self.has_hit = False
            self.attack_sound.play()

        # GRAVITY
        self.vel_y += 1
        if self.vel_y > 10:
            self.vel_y = 10
        dy += self.vel_y

        # GROUND COLLISION
        ground_layer = bg_images[0]
        ground_y = SCREEN_LENGTH - ground_layer.get_height()
        if self.rect.bottom + dy >= ground_y:
            dy = ground_y - self.rect.bottom
            self.jumped = False
            self.vel_y = 0

        # APPLY MOVEMENT
        self.rect.x += dx
        self.rect.y += dy

        # SCREEN BOUNDS
        if self.rect.left < 0:
            self.rect.left = 0
        elif self.rect.right > WORLD_WIDTH:
            self.rect.right = WORLD_WIDTH

        #which action is active
        if self.attacking:
            self.action = 3
        else:
            if self.jumped:
                self.action = 2
            elif dx != 0:
                self.action = 1
            else:
                self.action = 0

        #frame reset when animation
        if self.action != getattr(self, "previous_action", None):
            self.frame_index = 0
            self.last_update = pygame.time.get_ticks()
        self.previous_action = self.action

        # animations
        animation_cooldown = 90
        if pygame.time.get_ticks() - self.last_update > animation_cooldown:
            self.last_update = pygame.time.get_ticks()
            self.frame_index += 1

            if self.frame_index >= len(self.animation_list[self.action]):
                if self.attacking and self.action == 3:
                    self.attacking = False
                self.frame_index = 0

        #frame draw for character
        bottom = self.rect.bottom
        centerx = self.rect.centerx
        self.image = self.animation_list[self.action][self.frame_index]
        self.rect = self.image.get_rect()
        self.rect.bottom = bottom
        self.rect.centerx = centerx

        #check if dead
        if self.hp <= 0 and self.alive:
            self.alive = False
            self.action = 4
            self.frame_index = 0
            self.last_update = pygame.time.get_ticks()

    def draw(self, camera_offset_x):
        flipped_image = pygame.transform.flip(self.image, self.flip, False)
        draw_pos = self.rect.topleft - pygame.Vector2(camera_offset_x, 0)
        screen.blit(flipped_image, draw_pos)

    def reset(self, pos_x, pos_y, name, max_hp, animation_steps = 4, scale = 3):
        self.name = name
        self.hp = max_hp
        self.alive = True
        self.animation_list = []
        self.animation_steps = animation_steps
        self.flip = False
        self.attacking = False
        self.has_hit = False
        self.jump_sound = pygame.mixer.Sound('Audio/character_jump.mp3')
        self.attack_sound = pygame.mixer.Sound('Audio/attack_fire.mp3')
        self.scale = scale
        self.last_update = pygame.time.get_ticks()
        self.frame_index = 0
        self.action = 0     #0:idle,  1 is walk, 2 is jump, 3 is attack, 4 is crouch
        self.max_hp = max_hp
        self.attack_damage = 10  # how much damage per hit
        self.attack_range = 80   # distance in front of character to detect a hit

        #load idle images
        temp_list = []

        sheet = pygame.image.load('Character/Idle/Character_idle.png').convert_alpha()

        frame_width = sheet.get_width() // self.animation_steps
        frame_height = sheet.get_height()

        for i in range(self.animation_steps):
            #sheet = pygame.transform.scale(sheet, (sheet.get_width() * 3, sheet.get_height() * 3))
            frame = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
           # blit the correct frame rectangle from the sheet onto 'frame'
            frame.blit(sheet, (0, 0), (i * frame_width, 0, frame_width, frame_height))
            # scale the extracted frame
            frame = pygame.transform.scale(frame, (frame_width * self.scale, frame_height * self.scale))
            temp_list.append(frame)

        self.animation_list.append(temp_list)

        #load WALK images
        temp_list = []
        sheet = pygame.image.load('Character/Walk/Character_walk.png').convert_alpha()

        frame_width = sheet.get_width() // 8
        frame_height = sheet.get_height()

        for i in range(8):
            frame = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
           # blit the correct frame rectangle from the sheet onto 'frame'
            frame.blit(sheet, (0, 0), (i * frame_width, 0, frame_width, frame_height))
            # scale the extracted frame
            frame = pygame.transform.scale(frame, (frame_width * self.scale, frame_height * self.scale))
            temp_list.append(frame)

        self.animation_list.append(temp_list)
        self.image = self.animation_list[self.action][self.frame_index]
        self.rect = self.image.get_rect()
        self.rect.center = (pos_x, pos_y)
        self.vel_y= 0
        self.jumped = False

        #load Jump images
        temp_list = []
        sheet = pygame.image.load('Character/Jump/Character_jump.png').convert_alpha()

        frame_width = sheet.get_width() // 8
        frame_height = sheet.get_height()

        for i in range(8):
            #sheet = pygame.transform.scale(sheet, (sheet.get_width() * 3, sheet.get_height() * 3))
            frame = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
           # blit the correct frame rectangle from the sheet onto frame
            frame.blit(sheet, (0, 0), (i * frame_width, 0, frame_width, frame_height))
            # scale the frame
            frame = pygame.transform.scale(frame, (frame_width * self.scale, frame_height * self.scale))
            temp_list.append(frame)

        self.animation_list.append(temp_list)
        self.image = self.animation_list[self.action][self.frame_index]
        self.rect = self.image.get_rect()
        self.rect.center = (pos_x, pos_y)
        self.vel_y= 0
        self.jumped = False

        # Load Attack Images_character
        temp_list = []

        sheet = pygame.image.load('Character/Attack/Character_attack.png').convert_alpha()

        frame_width = sheet.get_width() // 8 
        frame_height = sheet.get_height()

        for i in range(8): 
            frame = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
            frame.blit(sheet, (0, 0), (i * frame_width, 0, frame_width, frame_height))
            frame = pygame.transform.scale(frame, (frame_width * self.scale, frame_height * self.scale))
            temp_list.append(frame)

        self.animation_list.append(temp_list)

        # Load DEATH images_character
        temp_list = []
        sheet = pygame.image.load('Character/Death/Character_death.png').convert_alpha()
        frame_width = sheet.get_width() // 8  # adjust based on sheet size
        frame_height = sheet.get_height()
        for i in range(8):
            frame = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
            frame.blit(sheet, (0, 0), (i * frame_width, 0, frame_width, frame_height))
            frame = pygame.transform.scale(frame, (frame_width * self.scale, frame_height * self.scale))
            temp_list.append(frame)
        self.animation_list.append(temp_list)

class Enemy:
    def __init__(self, x, y, name, patrol_range=200, scale=3):
        self.name = name
        self.scale = scale
        self.animation_list = []
        self.frame_index = 0
        self.last_update = pygame.time.get_ticks()
        self.action = 0  # 0 = idle, 1 = walk
        self.flip = False
        self.direction = 1  # 1 = right, -1 = left
        self.speed = 3
        self.patrol_origin = x
        self.patrol_range = patrol_range
        self.attacking = False
        self.attack_cooldown = 1000 
        self.last_attack = 0
        self.max_hp = 50
        self.hp = 50
        self.alive = True

        # Load IDLE animation
        temp_list = []
        sheet = pygame.image.load('Toadman_voodoo/voodoo_idle.png').convert_alpha()
        frame_width = sheet.get_width() // 4
        frame_height = sheet.get_height()
        for i in range(4):
            frame = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
            frame.blit(sheet, (0, 0), (i * frame_width, 0, frame_width, frame_height))
            frame = pygame.transform.scale(frame, (frame_width * self.scale, frame_height * self.scale))
            temp_list.append(frame)
        self.animation_list.append(temp_list)

        # Load WALK animation
        temp_list = []
        sheet = pygame.image.load('Toadman_voodoo/voodoo_walk.png').convert_alpha()
        frame_width = sheet.get_width() // 6
        frame_height = sheet.get_height()
        for i in range(6):
            frame = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
            frame.blit(sheet, (0, 0), (i * frame_width, 0, frame_width, frame_height))
            frame = pygame.transform.scale(frame, (frame_width * self.scale, frame_height * self.scale))
            temp_list.append(frame)
        self.animation_list.append(temp_list)

        # Load ATTACK animation
        temp_list = []
        sheet = pygame.image.load('Toadman_voodoo/voodoo_attack.png').convert_alpha()
        frame_width = sheet.get_width() // 4  
        frame_height = sheet.get_height()
        for i in range(4):
            frame = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
            frame.blit(sheet, (0, 0), (i * frame_width, 0, frame_width, frame_height))
            frame = pygame.transform.scale(frame, (frame_width * self.scale, frame_height * self.scale))
            temp_list.append(frame)
        self.animation_list.append(temp_list)

        # Load DEATH animation
        temp_list = []
        sheet = pygame.image.load('Toadman_voodoo/voodoo_death.png').convert_alpha()
        frame_width = sheet.get_width() // 4
        frame_height = sheet.get_height()
        for i in range(4):
            frame = pygame.Surface((frame_width, frame_height), pygame.SRCALPHA)
            frame.blit(sheet, (0, 0), (i * frame_width, 0, frame_width, frame_height))
            frame = pygame.transform.scale(frame, (frame_width * self.scale, frame_height * self.scale))
            temp_list.append(frame)
        self.animation_list.append(temp_list)

         # Set up image & rect
        self.image = self.animation_list[self.action][self.frame_index]
        self.rect = self.image.get_rect()
        self.rect.center = (x, y)        
        #print("Enemy animations loaded:", len(self.animation_list), "sets")

    def update(self):

        current_time = pygame.time.get_ticks()

        #dead state
        if not self.alive:
            # Only dead state once
            if self.action != 3:
                self.action = 3  # death animation
                self.frame_index = 0
                self.last_update = current_time

            animation_cooldown = 120

            #clamp to avoid invalid splices
            if self.frame_index >= len(self.animation_list[self.action]):
                self.frame_index = len(self.animation_list[self.action]) - 1

            bottom = self.rect.bottom
            centerx = self.rect.centerx
            self.image = self.animation_list[self.action][self.frame_index]
            self.rect = self.image.get_rect()
            self.rect.bottom = bottom
            self.rect.centerx = centerx

            # play the death animation slowly
            if current_time - self.last_update > animation_cooldown:
                self.last_update = current_time
                self.frame_index += 1
                if self.frame_index >= len(self.animation_list[self.action]):
                    self.frame_index = len(self.animation_list[self.action]) - 1  # hold last frame
            return  # stop any other action after death

        # ATTACK
        if self.attacking:
            self.action = 2  # attack
            animation_cooldown = 120

            if self.frame_index >= len(self.animation_list[self.action]):
                self.frame_index = 0

            bottom = self.rect.bottom
            centerx = self.rect.centerx
            self.image = self.animation_list[self.action][self.frame_index]
            self.rect = self.image.get_rect()
            self.rect.bottom = bottom
            self.rect.centerx = centerx

            if current_time - self.last_update > animation_cooldown:
                self.last_update = current_time
                self.frame_index += 1
                if self.frame_index >= len(self.animation_list[self.action]):
                    self.frame_index = 0
                    self.attacking = False
            return

        #PATROL_ENEMY
        self.rect.x += self.direction * self.speed
        if self.rect.centerx > self.patrol_origin + self.patrol_range:
            self.direction = -1
            self.flip = False
        elif self.rect.centerx < self.patrol_origin - self.patrol_range:
            self.direction = 1
            self.flip = True

        #WALK_ENEMY
        self.action = 1  # walk
        animation_cooldown = 150
        if current_time - self.last_update > animation_cooldown:
            self.last_update = current_time
            self.frame_index = (self.frame_index + 1) % len(self.animation_list[self.action])

        if self.frame_index >= len(self.animation_list[self.action]):
            self.frame_index = 0

        bottom = self.rect.bottom
        centerx = self.rect.centerx
        self.image = self.animation_list[self.action][self.frame_index]
        self.rect = self.image.get_rect()
        self.rect.bottom = bottom
        self.rect.centerx = centerx

        #ATTACK_ENEMY collision
        if self.alive and abs(self.rect.centerx - Mage.rect.centerx) < 100:
            # Attack only after cooldown
            if current_time - self.last_attack > self.attack_cooldown:
                self.attacking = True
                self.last_attack = current_time
                Mage.hp -= 8  # ENEMY DMG PER HIT
                if Mage.hp <= 0:
                    Mage.alive = False

        #PREVENTS OVERLAPPING
        self.action = max(0, min(self.action, len(self.animation_list) - 1))
        self.frame_index = max(0, min(self.frame_index, len(self.animation_list[self.action]) - 1))

    def Enemy_draw(self, surface, camera_offset_x):
        flipped_image = pygame.transform.flip(self.image, self.flip, False)
        #surface.blit(flipped_image, self.rect)
        draw_pos = self.rect.topleft - pygame.Vector2(camera_offset_x, 0 )
        surface.blit(flipped_image, draw_pos)
    
        #pygame.draw.rect(surface, (255, 0, 0), self.rect, 2)

def draw_health_bar_above(surface, entity, camera_offset_x):
    # Position above entity’s head
    bar_width = 80
    bar_height = 10
    ratio = max(entity.hp, 0) / entity.max_hp

    # Calculate position relative to camera
    draw_x = entity.rect.centerx - bar_width // 2 - camera_offset_x
    draw_y = entity.rect.top - 20

    # Draw health bar
    pygame.draw.rect(surface, (255, 0, 0), (draw_x, draw_y, bar_width, bar_height))  # red background
    pygame.draw.rect(surface, (0, 255, 0), (draw_x, draw_y, bar_width * ratio, bar_height))  # green overlay
    pygame.draw.rect(surface, (255, 255, 255), (draw_x, draw_y, bar_width, bar_height), 1)  # white border

class Camera:
    def __init__(self):
        self.offset = pygame.Vector2(0, 0)
        self.scroll_speed = 0.1  # smooth follow

    def update(self, target_rect):
        # Follow the player's position
        target_x = target_rect.centerx - SCREEN_WIDTH / 2
        
        world_width = len(bg_images) * bg_width
        target_x = max(0, min(target_x, WORLD_WIDTH - SCREEN_WIDTH))

        self.offset.x += (target_x - self.offset.x) * self.scroll_speed

Mage = Character(500, 650, 'Idle', 30, 4, 3)

enemies = [
    Enemy(800, 650, 'Enemy', patrol_range=150, scale=3),
    Enemy(1200, 650, 'Enemy', patrol_range=200, scale=3),
    Enemy(1600, 650, 'Enemy', patrol_range=100, scale=3)
]

#button
restart_button  = Button(SCREEN_WIDTH // 2 - 50, SCREEN_LENGTH // 2 + 100, restart_img)

camera = Camera()

#camera shake variables
shake_offset = [0, 0]
shake_timer = 0

#for restart
game_over =False

#game start loop
running = True
game_start = False
game_won = False
while running:
    clock.tick(FPS)

#events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        
        #ESC exit
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                running = False
        
        # Win screen controls
        if event.type == pygame.KEYDOWN:
            if game_won:
                if event.key == pygame.K_r:
                    # Restart game
                    Mage.reset(500, 650, 'Idle', 30, 4, 3)
                    enemies = [
                        Enemy(800, 650, 'Enemy', patrol_range=150, scale=3),
                        Enemy(1200, 650, 'Enemy', patrol_range=150, scale=3),
                        Enemy(1600, 650, 'Enemy', patrol_range=150, scale=3),
                    ]
                    game_won = False
                    game_over = False

                elif event.key == pygame.K_ESCAPE:
                    running = False



        #START SCREEN
        if game_start == False and event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RETURN:
                game_start = True


        if game_over and event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if restart_button.rect.collidepoint(event.pos):
                Mage.reset(500, 650, 'Idle', 30, 4, 3)
                enemies = [Enemy(800, 650, 'Enemy', patrol_range=150, scale=3),
                           Enemy(1200, 650,'Enemy', patrol_range=150, scale=3),
                           Enemy(1600, 650,'Enemy', patrol_range=150, scale=3),
                        ]
                game_over = False
    
    if not game_start:
        screen.blit(start_img, (-150, 0))
        pygame.display.update()
        continue

#load camera in first
    camera.update(Mage.rect)
    # === Screen shake logic
    if shake_timer > 0:
        shake_offset[0] = random.randint(-5, 5)
        shake_offset[1] = random.randint(-5, 5)
        shake_timer -= 1
    else:
        shake_offset = [0, 0]

#load in background
    draw_bg(camera.offset.x -  shake_offset[0])

#update/load Mage
    Mage.update()
    Mage.draw(camera.offset.x - shake_offset[0])
    #draws player health bar
    draw_health_bar_above(screen, Mage, camera.offset.x)

    #update/load Enemy
    for enemy in enemies:
        enemy.update()
        enemy.Enemy_draw(screen, camera.offset.x - shake_offset[0])

    # COLLISION DETECTION ENEMY
        if Mage.rect.colliderect(enemy.rect):
            if not enemy.attacking and pygame.time.get_ticks() - enemy.last_attack > enemy.attack_cooldown:
                enemy.attacking = True
                enemy.last_attack = pygame.time.get_ticks()
                enemy.action = 2      # force attack animation
                enemy.frame_index = 0 # restart animation cleanly

        # PLAYER ATTACKS ENEMY
        if Mage.attacking and not Mage.has_hit and Mage.rect.colliderect(enemy.rect):
            if enemy.alive:
                enemy.hp -= Mage.attack_damage
                Mage.has_hit = True
                #print(f"Enemy hit! HP left: {Voodoo_Toadman.hp}")

                shake_timer = 10

            # If HP is zero or less, mark enemy as dead
                if enemy.hp <= 0:
                    enemy.hp = 0
                    enemy.alive = False
                    enemy.action = 3
                    enemy.frame_index = 0
                    enemy.last_update = pygame.time.get_ticks()

        # Draw health bars
        draw_health_bar_above(screen, enemy, camera.offset.x)

    if Mage.alive == False:
        game_over = True
    if game_over:
        restart_button.draw()
    alive_enemies = [enemy for enemy in enemies if enemy.alive]
    if len(alive_enemies) == 0:
        game_won = True
    else:
        game_won = False

    # WIN SCREEN
    if game_won:
        font = pygame.font.Font(None, 74)
        win_text = font.render("YOU'VE WON!", True, (255, 255, 0))
        screen.blit(win_text, (SCREEN_WIDTH // 2 - win_text.get_width() // 2, 50))

        small_font = pygame.font.Font(None, 36)
        restart_text = small_font.render("Press R to Restart or ESC to Exit", True, (255, 255, 255))
        screen.blit(restart_text, (SCREEN_WIDTH // 2 - restart_text.get_width() // 2, 150))



    pygame.display.update()

pygame.quit()